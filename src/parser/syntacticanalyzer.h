#ifndef SYNTACTICANALYZER_H
#define SYNTACTICANALYZER_H
#include "../generic/generic.h"
#include <map>
#include <string>
#include <vector>
//#include "/home/tom/mySchool/PJP/gcc/gcc-src/gcc/sfe/lex.yy.c"
// Lexical Analyzer was Generated by GNU FLEX
#include "lex.yy.c"

/**
 * @struct TFunc
 * @brief Represents a function forward declaration with parameters, result declaration, and local variable map.
 */
struct TFunc { 
    tree params;                      ///< Parameters of the function
    tree resdecl;                     ///< Result declaration of the function
    tree fcdecl;                      ///< Function declaration
    std::map<std::string, tree> localVarMap;  ///< Map of local variables
};

/**
 * @brief Matches a string with a character array.
 * 
 * @param a The string to be matched.
 * @param b The character array to be matched.
 * @return bool True if matched, false otherwise.
 */
bool myMatch(const std::string & a, const char * b);

/**
 * @brief Handles errors with a formatted message.
 * 
 * @param format The format string for the error message.
 * @param ... Additional arguments for the format string.
 */
void handleError(const char * format, ...);

/**
 * @brief Prints a string in debug mode.
 * 
 * @param str The string to be printed.
 */
void print(const std::string & str);

/**
 * @class SyntacticAnalyzer
 * @brief Recursive Descent Parser for the Mila programming language using LL(1) Grammar.
 * 
 * This parser translates Mila code into an internal GCC tree (DAG) Generic format.
 */
class SyntacticAnalyzer
{
public:
    /**
     * @brief Constructs a SyntacticAnalyzer object.
     * 
     * @param inputFile The input file to be analyzed.
     * @param outputFile The output file where the results will be written.
     */
    SyntacticAnalyzer(FILE * inputFile, FILE * outputFile);

    /**
     * @brief Destroys the SyntacticAnalyzer object.
     */
    ~SyntacticAnalyzer();

public:
    /**
     * @brief Starts parsing the input file.
     */
    void parseFile();

private:
    /**
     * @brief Drops a token.
     * 
     * @param tid The token ID to be dropped.
     */
    void drop(TokenID tid);

    /**
     * @brief Drops a string token.
     * 
     * @param str The string to be dropped.
     */
    void dropStr(std::string & str);

    /**
     * @brief Drops an integer token.
     * 
     * @param num The integer to be dropped.
     */
    void dropInt(int & num);

    // ----------------------------------------------
    // Implementation of Grammar Symbol
    // ----------------------------------------------

    /**
     * @brief Processes the starting grammar symbol.
     */
    void S();

    /**
     * @brief Processes the zb grammar symbol.
     * 
     * @param globals The global variables tree.
     */
    void zb(tree globals);

    /**
     * @brief Processes the zb2 grammar symbol.
     * 
     * @param globals The global variables tree.
     */
    void zb2(tree globals);

    /**
     * @brief Processes a block of constants.
     * 
     * @param vmap A map of variable names to tree nodes.
     */
    void constbl(std::map<std::string, tree> & vmap);

    /**
     * @brief Processes a block of variables.
     * 
     * @param decls The tree node representing declarations.
     * @param vmap A map of variable names to tree nodes.
     * @param global A flag indicating if the variable is global.
     * @return tree The constructed tree node.
     */
    tree varbl(tree decls, std::map<std::string, tree> & vmap, bool global);

    /**
     * @brief Processes a list of identifiers.
     * 
     * @param names A vector to store the names of the identifiers.
     */
    void idlist(std::vector<std::string> & names);

    /**
     * @brief Processes a secondary list of identifiers.
     * 
     * @param names A vector to store the names of the identifiers.
     */
    void idlist2(std::vector<std::string> & names);

    /**
     * @brief Processes a type.
     * 
     * @param from The starting value of the type.
     * @param to The ending value of the type.
     * @return bool True if the type is an array, false otherwise.
     */
    bool type(int & from, int & to);

    /**
     * @brief Processes an interval.
     * 
     * @param from The starting value of the interval.
     * @param to The ending value of the interval.
     */
    void interval(int & from, int & to);

    /**
     * @brief Processes a function declaration.
     */
    void funcDec();

    /**
     * @brief Processes function parameters.
     * 
     * @param param_decl The tree node representing parameter declarations.
     * @param params The tree node representing parameters.
     */
    void parameters(tree & param_decl, tree & params);

    /**
     * @brief Processes a secondary function declaration.
     * 
     * @param var The tree node representing the variable.
     * @param stmt The tree node representing the statement.
     * @return bool True if the declaration is immediate, false if forward.
     */
    bool funcDec2(tree & var, tree & stmt);

    /**
     * @brief Processes an optional component.
     * 
     * @return tree The constructed tree node.
     */
    tree optional();

    /**
     * @brief Processes a secondary optional component.
     * 
     * @return tree The constructed tree node.
     */
    tree optional2();

    /**
     * @brief Processes the main function.
     * 
     * @param globals The global variables tree.
     * @return tree The constructed tree node.
     */
    tree main(tree globals);

    /**
     * @brief Processes the body of a function.
     * 
     * @param decls The tree node representing declarations.
     * @param bind The tree node representing bindings.
     * @param blk The tree node representing the block.
     * @return tree The constructed tree node.
     */
    tree body(tree decls, tree & bind, tree & blk);

    /**
     * @brief Processes a block of code.
     * 
     * @return tree The constructed tree node.
     */
    tree block();

    /**
     * @brief Processes a recursion statement.
     * 
     * @param stmt The tree node representing the statement.
     */
    void recursion(tree & stmt);

    /**
     * @brief Processes a command.
     * 
     * @param statementParam The tree node representing the statement parameter.
     * @return tree The constructed tree node.
     */
    tree command(tree & statementParam);

    /**
     * @brief Processes a return statement.
     * 
     * @return tree The constructed tree node.
     */
    tree build_return();

    /**
     * @brief Processes an if condition block.
     * 
     * @return tree The constructed tree node.
     */
    tree ifconstruction();

    /**
     * @brief Processes an else block.
     * 
     * @return tree The constructed tree node.
     */
    tree elseblock();

    /**
     * @brief Processes a for loop construction.
     * 
     * @param statementParam The tree node representing the statement parameter.
     * @return tree The constructed tree node.
     */
    tree forconstruction(tree & statementParam);

    /**
     * @brief Processes a where clause.
     * 
     * @param to A flag indicating the direction of the clause.
     */
    void where(bool & to);

    /**
     * @brief Processes a while loop construction.
     * 
     * @return tree The constructed tree node.
     */
    tree whileconstruction();

    /**
     * @brief Processes an assignment statement.
     * 
     * @param name The name of the variable to be assigned.
     * @return tree The constructed tree node.
     */
    tree assigment(const std::string & name);

    /**
     * @brief Processes a function call.
     * 
     * @param name The name of the function to be called.
     * @return tree The constructed tree node.
     */
    tree call(const std::string & name);

    /**
     * @brief Processes a list of values for a function call.
     * 
     * @param vec A vector to store the tree nodes representing the values.
     */
    void val_list(std::vector<tree> & vec);

    /**
     * @brief Processes a logical expression.
     * 
     * @return tree The constructed tree node.
     */
    tree logical_expression();

    /**
     * @brief Processes a logical expression with OR operator.
     * 
     * @param left The tree node representing the left-hand side of the expression.
     * @return tree The constructed tree node.
     */
    tree LE2(tree left);

    /**
     * @brief Processes a logical expression TERM.
     * 
     * @return tree The constructed tree node.
     */
    tree LT();

    /**
     * @brief Processes a logical expression TERM with AND operator.
     * 
     * @param left The tree node representing the left-hand side of the expression.
     * @return tree The constructed tree node.
     */
    tree LT2(tree left);

    /**
     * @brief Processes a logical expression FACTOR.
     * 
     * @return tree The constructed tree node.
     */
    tree LF();

    /**
     * @brief Processes a logical expression FACTOR.
     * 
     * @param left The tree node representing the left-hand side of the factor.
     * @return tree The constructed tree node.
     */
    tree LF2(tree left);

    /**
     * @brief Processes an arithmetic expression.
     * 
     * @return tree The constructed tree node.
     */
    tree aritmetic_expression();

    /**
     * @brief Processes an arithmetic expression with low priority operators.
     * 
     * @param left The tree node representing the left-hand side of the expression.
     * @return tree The constructed tree node.
     */
    tree AE2(tree left);

    /**
     * @brief Processes an arithmetic expression TERM.
     * 
     * @return tree The constructed tree node.
     */
    tree AT();

    /**
     * @brief Processes an arithmetic expression TERM with looping.
     * 
     * @param left The

 tree node representing the left-hand side of the term.
     * @return tree The constructed tree node.
     */
    tree AT2(tree left);

    /**
     * @brief Processes an arithmetic expression FACTOR.
     * 
     * @return tree The constructed tree node.
     */
    tree AF();

    /**
     * @brief Looks up a parsed variable.
     * 
     * @param name The name of the variable to be looked up.
     * @return tree The constructed tree node.
     */
    tree findVariable(const std::string & name);

    /**
     * @brief Looks up a parsed simple variable.
     * 
     * @param name The name of the variable to be looked up.
     * @return tree The constructed tree node.
     */
    tree findSimpleVariable(const std::string & name);

    /**
     * @brief Looks up a parsed function.
     * 
     * @param name The name of the function to be looked up.
     * @param onlyCheck A flag indicating if only a check is needed.
     * @return tree The constructed tree node.
     */
    tree findFunction(const std::string & name, bool onlyCheck = false);

    /**
     * @brief Looks up a parsed forward declaration of a function.
     * 
     * @param name The name of the function to be looked up.
     * @return TFunc* The function forward declaration.
     */
    TFunc * findFunctionFw(const std::string & name);

    /**
     * @brief Registers a parsed global variable.
     * 
     * @param gv The tree node representing the global variable.
     */
    void registerGlobalVarible(tree gv);

    /**
     * @brief Registers a parsed function.
     * 
     * @param fc The tree node representing the function.
     */
    void registerFunction(tree fc);

    /**
     * @brief Dumps the generic tree.
     * 
     * @param fndecl The tree node representing the function declaration.
     */
    void tree_dump_original(tree fndecl);

    /**
     * @brief Loads the next token.
     * 
     * @return bool True if there are more tokens, false otherwise.
     */
    bool nextToken();

public:
    std::map<std::string, tree> funcMap;       /**< Map of function names to tree nodes. */
    std::map<std::string, tree> varMap;        /**< Map of variable names to tree nodes. */
    std::map<std::string, tree> localVarMap;   /**< Map of local variable names to tree nodes. */
    std::map<std::string, int> idxMap;         /**< Map of names to indices. */
    std::map<std::string, TFunc *> funcFwMap;  /**< Map of function forward declarations. */

    tree statement;             /**< The current statement tree node. */
    vec<tree, va_gc> * fileVec; /**< Vector of file tree nodes. */
    bool isFunc;                /**< Flag indicating if the current context is a function. */
};

